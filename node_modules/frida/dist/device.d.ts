/// <reference types="node" />
import { Application } from "./application";
import { Cancellable } from "./cancellable";
import { Child } from "./child";
import { Crash } from "./crash";
import { Icon } from "./icon";
import { IOStream } from "./iostream";
import { Process } from "./process";
import { Session } from "./session";
import { Signal } from "./signals";
import { Spawn } from "./spawn";
import { inspect } from "util";
export declare class Device {
    private impl;
    spawnAdded: Signal<SpawnAddedHandler>;
    spawnRemoved: Signal<SpawnRemovedHandler>;
    childAdded: Signal<ChildAddedHandler>;
    childRemoved: Signal<ChildRemovedHandler>;
    processCrashed: Signal<ProcessCrashedHandler>;
    output: Signal<OutputHandler>;
    uninjected: Signal<UninjectedHandler>;
    lost: Signal<DeviceLostHandler>;
    constructor(impl: any);
    get id(): string;
    get name(): string;
    get icon(): Icon;
    get type(): DeviceType;
    getFrontmostApplication(cancellable?: Cancellable): Promise<Application | null>;
    enumerateApplications(cancellable?: Cancellable): Promise<Application[]>;
    enumerateProcesses(cancellable?: Cancellable): Promise<Process[]>;
    getProcess(name: string, cancellable?: Cancellable): Promise<Process>;
    enableSpawnGating(cancellable?: Cancellable): Promise<void>;
    disableSpawnGating(cancellable?: Cancellable): Promise<void>;
    enumeratePendingSpawn(cancellable?: Cancellable): Promise<Spawn[]>;
    enumeratePendingChildren(cancellable?: Cancellable): Promise<Child[]>;
    spawn(program: string | string[], options?: SpawnOptions, cancellable?: Cancellable): Promise<ProcessID>;
    input(target: TargetProcess, data: Buffer, cancellable?: Cancellable): Promise<void>;
    resume(target: TargetProcess, cancellable?: Cancellable): Promise<void>;
    kill(target: TargetProcess, cancellable?: Cancellable): Promise<void>;
    attach(targetOrParameters: TargetProcess | AttachParameters, cancellable?: Cancellable): Promise<Session>;
    injectLibraryFile(target: TargetProcess, path: string, entrypoint: string, data: string, cancellable?: Cancellable): Promise<InjecteeID>;
    injectLibraryBlob(target: TargetProcess, blob: Buffer, entrypoint: string, data: string, cancellable?: Cancellable): Promise<InjecteeID>;
    openChannel(address: string, cancellable?: Cancellable): Promise<IOStream>;
    private getPid;
    [inspect.custom](depth: any, options: any): string;
}
export declare type ProcessID = number;
export declare type ProcessName = string;
export declare type InjecteeID = number;
export declare type FileDescriptor = number;
export declare type SpawnAddedHandler = (spawn: Spawn) => void;
export declare type SpawnRemovedHandler = (spawn: Spawn) => void;
export declare type ChildAddedHandler = (child: Child) => void;
export declare type ChildRemovedHandler = (child: Child) => void;
export declare type ProcessCrashedHandler = (crash: Crash) => void;
export declare type OutputHandler = (pid: ProcessID, fd: FileDescriptor, data: Buffer) => void;
export declare type UninjectedHandler = (id: InjecteeID) => void;
export declare type DeviceLostHandler = () => void;
export declare enum DeviceType {
    Local = "local",
    Remote = "remote",
    Usb = "usb"
}
export interface SpawnOptions {
    argv?: string[];
    envp?: {
        [name: string]: string;
    };
    env?: {
        [name: string]: string;
    };
    cwd?: string;
    stdio?: Stdio;
    [name: string]: any;
}
export declare enum Stdio {
    Inherit = "inherit",
    Pipe = "pipe"
}
export declare type TargetProcess = ProcessID | ProcessName;
export interface AttachParameters {
    target: TargetProcess;
    realm?: Realm;
}
export declare enum Realm {
    Native = "native",
    Emulated = "emulated"
}
